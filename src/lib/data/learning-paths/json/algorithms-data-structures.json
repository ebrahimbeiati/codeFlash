{
  "id": "algorithms-data-structures",
  "title": "Algorithms & Data Structures",
  "description": "Master fundamental algorithms and data structures for efficient problem solving",
  "level": "intermediate",
  "sets": [
    {
      "id": "basic-data-structures",
      "title": "Basic Data Structures",
      "description": "Fundamental data structures every programmer should know",
      "category": "data-structures",
      "cards": [
        {
          "id": "bds-1",
          "front": "What is an array?",
          "back": "An array is a linear data structure that stores elements in contiguous memory locations. Elements can be accessed directly using an index. Arrays have O(1) access time but O(n) insertion/deletion.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-2",
          "front": "What is a linked list?",
          "back": "A linked list is a linear data structure where elements are stored in nodes, and each node points to the next node. It has O(n) access time but O(1) insertion/deletion at the beginning.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-3",
          "front": "What is a stack?",
          "back": "A stack is a LIFO (Last In, First Out) data structure. Elements can only be added or removed from the top. Common operations are push, pop, and peek, all with O(1) time complexity.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-4",
          "front": "What is a queue?",
          "back": "A queue is a FIFO (First In, First Out) data structure. Elements are added at the rear and removed from the front. Common operations are enqueue, dequeue, and peek, all with O(1) time complexity.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-5",
          "front": "What is a hash table?",
          "back": "A hash table is a data structure that stores key-value pairs. It uses a hash function to map keys to array indices, providing average O(1) time complexity for insert, delete, and search operations.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-6",
          "front": "What is a binary tree?",
          "back": "A binary tree is a hierarchical data structure where each node has at most two children (left and right). It's used for efficient searching, sorting, and hierarchical data representation.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-7",
          "front": "What is a binary search tree (BST)?",
          "back": "A BST is a binary tree where for each node, all values in the left subtree are less than the node's value, and all values in the right subtree are greater. This enables O(log n) search operations.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-8",
          "front": "What is a heap?",
          "back": "A heap is a complete binary tree that satisfies the heap property. In a max heap, parent nodes are always greater than or equal to their children. Used for priority queues and heap sort.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-9",
          "front": "What is a graph?",
          "back": "A graph is a data structure consisting of vertices (nodes) connected by edges. It can be directed or undirected, weighted or unweighted. Used to represent relationships and networks.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-10",
          "front": "What is a set?",
          "back": "A set is a collection of unique elements with no specific order. It supports operations like add, remove, and contains. Implemented using hash tables for O(1) average time complexity.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-11",
          "front": "What is a map/dictionary?",
          "back": "A map is a data structure that stores key-value pairs where each key is unique. It provides fast lookup, insertion, and deletion operations, typically implemented using hash tables.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-12",
          "front": "What is a trie?",
          "back": "A trie (prefix tree) is a tree-like data structure used to store strings. Each node represents a character, and paths from root to leaf represent complete strings. Efficient for prefix searches.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-13",
          "front": "What is a deque?",
          "back": "A deque (double-ended queue) allows insertion and deletion from both ends. It combines the features of stacks and queues, providing O(1) time complexity for operations at both ends.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-14",
          "front": "What is a priority queue?",
          "back": "A priority queue is a data structure where elements are removed based on priority rather than insertion order. Typically implemented using heaps, providing O(log n) insertion and O(log n) removal (and O(1) access to the highest-priority element).",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-15",
          "front": "What is a union-find data structure?",
          "back": "Union-find (disjoint-set) is a data structure that tracks a set of elements partitioned into disjoint subsets. It supports union and find operations, used in algorithms like Kruskal's MST.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-16",
          "front": "What is a skip list?",
          "back": "A skip list is a probabilistic data structure that allows O(log n) search complexity. It consists of multiple layers of linked lists, with higher layers having fewer elements.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "bds-17",
          "front": "What is a bloom filter?",
          "back": "A bloom filter is a probabilistic data structure used to test whether an element is a member of a set. It may have false positives but never false negatives, providing space-efficient membership testing.",
          "category": "data-structures",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        }
      ]
    },
    {
      "id": "basic-algorithms",
      "title": "Basic Algorithms",
      "description": "Essential algorithms for problem solving",
      "category": "algorithms",
      "cards": [
        {
          "id": "ba-1",
          "front": "What is linear search?",
          "back": "Linear search is a simple algorithm that checks each element in a list sequentially until the target is found or the end is reached. Time complexity is O(n) in the worst case.",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-2",
          "front": "What is binary search?",
          "back": "Binary search is an efficient algorithm for finding an element in a sorted array. It repeatedly divides the search interval in half, achieving O(log n) time complexity.",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-3",
          "front": "What is bubble sort?",
          "back": "Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. Time complexity is O(n²).",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-4",
          "front": "What is selection sort?",
          "back": "Selection sort divides the array into sorted and unsorted regions. It repeatedly selects the smallest element from the unsorted region and places it in the sorted region. Time complexity is O(n²).",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-5",
          "front": "What is insertion sort?",
          "back": "Insertion sort builds the final sorted array one item at a time. It takes each element and inserts it into its correct position in the sorted portion. Time complexity is O(n²) but efficient for small arrays.",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-6",
          "front": "What is merge sort?",
          "back": "Merge sort is a divide-and-conquer algorithm that recursively divides the array into halves, sorts them, and merges the sorted halves. Time complexity is O(n log n) and it's stable.",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-7",
          "front": "What is quick sort?",
          "back": "Quick sort is a divide-and-conquer algorithm that picks a pivot element and partitions the array around it. Average time complexity is O(n log n), but worst case is O(n²).",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-8",
          "front": "What is heap sort?",
          "back": "Heap sort uses a binary heap data structure to sort elements. It first builds a max heap, then repeatedly extracts the maximum element. Time complexity is O(n log n) and it's in-place.",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-9",
          "front": "What is depth-first search (DFS)?",
          "back": "DFS is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It uses a stack (or recursion) and is useful for topological sorting and cycle detection.",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-10",
          "front": "What is breadth-first search (BFS)?",
          "back": "BFS is a graph traversal algorithm that explores all vertices at the current depth before moving to vertices at the next depth level. It uses a queue and is useful for shortest path problems.",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-11",
          "front": "What is the two-pointer technique?",
          "back": "The two-pointer technique uses two pointers to solve problems efficiently. Common applications include finding pairs in sorted arrays, removing duplicates, and detecting cycles in linked lists.",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-12",
          "front": "What is the sliding window technique?",
          "back": "The sliding window technique maintains a subset of elements (window) that slides through the array. It's useful for problems involving subarrays or substrings with specific properties.",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-13",
          "front": "What is the greedy approach?",
          "back": "The greedy approach makes locally optimal choices at each step with the hope of finding a global optimum. It's simple but doesn't always guarantee the best solution.",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-14",
          "front": "What is dynamic programming?",
          "back": "Dynamic programming solves complex problems by breaking them into simpler subproblems and storing the results. It avoids redundant calculations and is used for optimization problems.",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-15",
          "front": "What is backtracking?",
          "back": "Backtracking is a systematic way to search for solutions by trying different choices and undoing them if they don't lead to a solution. Used for constraint satisfaction problems.",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ba-16",
          "front": "What is the divide-and-conquer approach?",
          "back": "Divide-and-conquer breaks a problem into smaller subproblems, solves them recursively, and combines the solutions. Examples include merge sort, quick sort, and binary search.",
          "category": "algorithms",
          "difficulty": "easy",
          "reviewCount": 0,
          "correctCount": 0
        }
      ]
    },
    {
      "id": "advanced-concepts",
      "title": "Advanced Concepts",
      "description": "Advanced algorithms and optimization techniques",
      "category": "advanced",
      "cards": [
        {
          "id": "ac-1",
          "front": "What is Dijkstra's algorithm?",
          "back": "Dijkstra's algorithm finds the shortest path between nodes in a weighted graph. It uses a priority queue and has O((V + E) log V) time complexity with a binary heap implementation.",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-2",
          "front": "What is the Floyd-Warshall algorithm?",
          "back": "Floyd-Warshall finds shortest paths between all pairs of vertices in a weighted graph. It uses dynamic programming and has O(V³) time complexity, working with negative weights (no negative cycles).",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-3",
          "front": "What is Kruskal's algorithm?",
          "back": "Kruskal's algorithm finds a minimum spanning tree for a weighted graph. It sorts edges by weight and uses union-find to avoid cycles. Time complexity is O(E log E) where E is the number of edges.",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-4",
          "front": "What is Prim's algorithm?",
          "back": "Prim's algorithm finds a minimum spanning tree by growing it from a starting vertex. It uses a priority queue to select the minimum weight edge. Time complexity is O(E log V) with a binary heap.",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-5",
          "front": "What is the Knapsack problem?",
          "back": "The Knapsack problem involves selecting items with given weights and values to maximize total value while staying within a weight limit. It's solved using dynamic programming with O(nW) complexity.",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-6",
          "front": "What is the Longest Common Subsequence (LCS)?",
          "back": "LCS finds the longest subsequence present in both strings. It's solved using dynamic programming with O(mn) time complexity, where m and n are the lengths of the input strings.",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-7",
          "front": "What is the Edit Distance problem?",
          "back": "Edit Distance (Levenshtein) measures the minimum number of operations (insert, delete, substitute) to transform one string into another. Solved with dynamic programming in O(mn) time.",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-8",
          "front": "What is the Traveling Salesman Problem (TSP)?",
          "back": "TSP finds the shortest possible route visiting each city exactly once and returning to the starting city. It's NP-hard, with exact solutions using dynamic programming in O(n²2ⁿ) time.",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-9",
          "front": "What is memoization?",
          "back": "Memoization is an optimization technique that stores the results of expensive function calls and returns the cached result when the same inputs occur again. It's a top-down approach to dynamic programming.",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-10",
          "front": "What is tabulation?",
          "back": "Tabulation is a bottom-up approach to dynamic programming that builds the solution iteratively, starting from the base cases. It avoids recursion overhead and is often more space-efficient.",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-11",
          "front": "What is the Boyer-Moore algorithm?",
          "back": "Boyer-Moore is a string searching algorithm that uses two heuristics (bad character and good suffix) to skip comparisons. It has O(nm) worst case but often performs better in practice.",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-12",
          "front": "What is the KMP (Knuth-Morris-Pratt) algorithm?",
          "back": "KMP is a string searching algorithm that uses a failure function to avoid unnecessary comparisons. It has O(n + m) time complexity, where n and m are the lengths of the text and pattern.",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-13",
          "front": "What is the A* search algorithm?",
          "back": "A* is an informed search algorithm that uses a heuristic function to estimate the cost to reach the goal. It combines the cost to reach a node with the estimated cost to the goal.",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-14",
          "front": "What is the Bellman-Ford algorithm?",
          "back": "Bellman-Ford finds shortest paths in a weighted graph and can handle negative weights. It relaxes all edges V-1 times and has O(VE) time complexity. It can detect negative cycles.",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-15",
          "front": "What is the Topological Sort algorithm?",
          "back": "Topological sort orders vertices in a directed acyclic graph so that all edges point forward. It uses DFS with a stack or Kahn's algorithm with in-degree counting. Time complexity is O(V + E).",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-16",
          "front": "What is the Tarjan's algorithm?",
          "back": "Tarjan's algorithm finds strongly connected components in a directed graph using DFS. It uses low-link values and a stack to identify components. Time complexity is O(V + E).",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        },
        {
          "id": "ac-17",
          "front": "What is the Union-Find with path compression?",
          "back": "Union-Find with path compression and union by rank achieves near-constant time complexity for union and find operations. Path compression makes each node point directly to the root.",
          "category": "advanced",
          "difficulty": "hard",
          "reviewCount": 0,
          "correctCount": 0
        }
      ]
    }
  ],
  "quizzes": [
    {
      "questions": [
        {
          "id": "q1",
          "question": "Which data structure provides O(1) average time complexity for insert, delete, and search operations?",
          "options": [
            "Array",
            "Linked List",
            "Hash Table",
            "Binary Tree"
          ],
          "correctAnswer": 2
        },
        {
          "id": "q2",
          "question": "What is the time complexity of binary search on a sorted array?",
          "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n²)"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q3",
          "question": "Which sorting algorithm has the best average-case time complexity?",
          "options": [
            "Bubble Sort",
            "Quick Sort",
            "Selection Sort",
            "Insertion Sort"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q4",
          "question": "What is the main advantage of a stack data structure?",
          "options": [
            "Fast random access",
            "LIFO operations are O(1)",
            "Can store unlimited elements",
            "Supports sorting"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q5",
          "question": "Which graph traversal algorithm uses a queue?",
          "options": [
            "Depth-First Search",
            "Breadth-First Search",
            "Both",
            "Neither"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q6",
          "question": "What is the time complexity of merge sort?",
          "options": [
            "O(n)",
            "O(n log n)",
            "O(n²)",
            "O(log n)"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q7",
          "question": "Which data structure is best for implementing a priority queue?",
          "options": [
            "Array",
            "Linked List",
            "Heap",
            "Hash Table"
          ],
          "correctAnswer": 2
        },
        {
          "id": "q8",
          "question": "What is the main characteristic of a binary search tree?",
          "options": [
            "All nodes have exactly two children",
            "Left subtree values < node < right subtree values",
            "It's always balanced",
            "It has O(1) search time"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q9",
          "question": "Which algorithm is used to find the shortest path in a weighted graph?",
          "options": [
            "BFS",
            "DFS",
            "Dijkstra's",
            "Quick Sort"
          ],
          "correctAnswer": 2
        },
        {
          "id": "q10",
          "question": "What is the time complexity of accessing an element in an array?",
          "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n²)"
          ],
          "correctAnswer": 0
        },
        {
          "id": "q11",
          "question": "Which data structure is used to implement a queue?",
          "options": [
            "Stack",
            "Linked List",
            "Tree",
            "Hash Table"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q12",
          "question": "What is the worst-case time complexity of quick sort?",
          "options": [
            "O(n log n)",
            "O(n²)",
            "O(n)",
            "O(log n)"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q13",
          "question": "Which algorithm uses divide-and-conquer strategy?",
          "options": [
            "Linear Search",
            "Bubble Sort",
            "Merge Sort",
            "Selection Sort"
          ],
          "correctAnswer": 2
        },
        {
          "id": "q14",
          "question": "What is the main advantage of dynamic programming?",
          "options": [
            "Always finds optimal solution",
            "Avoids redundant calculations",
            "Works with any problem",
            "Has constant time complexity"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q15",
          "question": "Which data structure is best for checking if an element exists?",
          "options": [
            "Array",
            "Linked List",
            "Set",
            "Stack"
          ],
          "correctAnswer": 2
        },
        {
          "id": "q16",
          "question": "What is the time complexity of inserting at the beginning of a linked list?",
          "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n²)"
          ],
          "correctAnswer": 0
        },
        {
          "id": "q17",
          "question": "Which sorting algorithm is stable?",
          "options": [
            "Quick Sort",
            "Heap Sort",
            "Merge Sort",
            "Selection Sort"
          ],
          "correctAnswer": 2
        },
        {
          "id": "q18",
          "question": "What is the purpose of a hash function in a hash table?",
          "options": [
            "To encrypt data",
            "To map keys to array indices",
            "To sort elements",
            "To compress data"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q19",
          "question": "Which algorithm is used to find minimum spanning tree?",
          "options": [
            "Dijkstra's",
            "Kruskal's",
            "Floyd-Warshall",
            "Bellman-Ford"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q20",
          "question": "What is the time complexity of searching in a binary search tree?",
          "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n²)"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q21",
          "question": "Which data structure is used for implementing a stack?",
          "options": [
            "Queue",
            "Array",
            "Tree",
            "Graph"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q22",
          "question": "What is the main disadvantage of bubble sort?",
          "options": [
            "It's not stable",
            "High time complexity O(n²)",
            "It requires extra space",
            "It doesn't work with strings"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q23",
          "question": "Which algorithm is used for cycle detection in a graph?",
          "options": [
            "BFS",
            "DFS",
            "Both DFS and BFS",
            "Neither"
          ],
          "correctAnswer": 2
        },
        {
          "id": "q24",
          "question": "What is the time complexity of heap sort?",
          "options": [
            "O(n)",
            "O(n log n)",
            "O(n²)",
            "O(log n)"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q25",
          "question": "Which data structure is best for implementing a dictionary?",
          "options": [
            "Array",
            "Linked List",
            "Hash Table",
            "Stack"
          ],
          "correctAnswer": 2
        },
        {
          "id": "q26",
          "question": "What is the main advantage of a trie data structure?",
          "options": [
            "Fast random access",
            "Efficient prefix searches",
            "Constant time operations",
            "Automatic sorting"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q27",
          "question": "Which algorithm uses the greedy approach?",
          "options": [
            "Quick Sort",
            "Dijkstra's",
            "Merge Sort",
            "Binary Search"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q28",
          "question": "What is the time complexity of the Floyd-Warshall algorithm?",
          "options": [
            "O(V²)",
            "O(V³)",
            "O(V log V)",
            "O(E log V)"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q29",
          "question": "Which data structure is used for implementing a bloom filter?",
          "options": [
            "Array",
            "Hash Table",
            "Tree",
            "Graph"
          ],
          "correctAnswer": 0
        },
        {
          "id": "q30",
          "question": "What is the main characteristic of a max heap?",
          "options": [
            "All nodes are equal",
            "Parent nodes are greater than children",
            "It's always balanced",
            "It has O(1) search time"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q31",
          "question": "Which algorithm is used for topological sorting?",
          "options": [
            "BFS",
            "DFS",
            "Both DFS and BFS",
            "Neither"
          ],
          "correctAnswer": 2
        },
        {
          "id": "q32",
          "question": "What is the time complexity of union-find with path compression?",
          "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "Nearly constant"
          ],
          "correctAnswer": 3
        },
        {
          "id": "q33",
          "question": "Which data structure is best for implementing a cache?",
          "options": [
            "Array",
            "Linked List",
            "Hash Table",
            "Stack"
          ],
          "correctAnswer": 2
        },
        {
          "id": "q34",
          "question": "What is the main advantage of memoization?",
          "options": [
            "Reduces space complexity",
            "Avoids redundant calculations",
            "Improves worst-case time",
            "Makes code simpler"
          ],
          "correctAnswer": 1
        },
        {
          "id": "q35",
          "question": "Which algorithm is used for string pattern matching?",
          "options": [
            "KMP",
            "Quick Sort",
            "Dijkstra's",
            "Merge Sort"
          ],
          "correctAnswer": 0
        }
      ]
    }
  ]
}